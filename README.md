# GraphL

GraphL is a Graph-Processing DSL (Domain-Specific Language) that lets you easily build graphs and run algorithms on them. 

## Key Features
Graph Representation:
- Support for multiple graph types (directed, undirected, weighted, unweighted)
- Easy syntax to define and manipulate graphs.

Graph Manipulation:
- Functions to add, remove, and modify nodes and edges.
- Ability to update properties like weights and labels.

## Functional requirements
The following are the functional requirements outlined at the start of development. Those in **bold** have been deemed essential.
- **Define set of Nodes**
- **Define set of Edges**
	- **directed**
	- undirected
- Weights
	- Nodes
	- Edges
	- Weight datatypes must be consistent (all ints or all floats)
- Node names
- Import and export graphs
- Add/remove single Nodes
- **Add/remove single Edges**
- Preprogrammed depth and breadth search
- **while-Loop**
- foreach-Loop
- **Control flow (if)**
- **Arthmetic operators**
- **Boolean operators**
- **"print()"-statements**
- Functions
	- return values
- Variables/Data structures
	- **Node**
	- **Edge**
	- Numeral
		- **float** / int
	- **Bools**
	- **List**/Set
	- Queue
	- Stack
	- String

## General syntax
- Indentation for blocks/scopes
- Individual statements separated by newlines
- Data type inferred 
	- Data type cannot be changed after initialization
	- Likewise, all elements of a list must be of the same data type
- "Pythonic" control flow statements 
- Artimetic operations: +, -, *, / 
- Boolean operators (and, or, not) and values (true, false) are always written in lowercase

## Functions and Methods

### Graph methods
- Constructor: `Graph([Number of nodes])`
- `[Graph].addNode()`
- `[Graph].addEdge([Edge])`
- `[Graph].AddEdges([List of edges])`
- `[Graph].getNode([Node ID])`
- `[Graph].getEdge([Origin node ID, Destination node ID])`
- `[Graph].setEdgeWeight([Edge],[Weight])`
- `[Graph].swapDirection([Edge])`
- `[Graph].removeEdge([Edge])`
- `[Graph].removeNode([Node])`

### Edge methods
- Constructor: `Edge([fromId], [toId], [weight - default 1.0])`
- `[Edge].swapDirection()`

### Node methods
- Constructor: `Node()`
- `[Node].addEdge([Edge])`
- `[Node].removeEdge([Edge])`
- `[Node].findIngoingedge([Node])`
- `[Node].findOutgoingedge([Node])`
- `[Node].addIngoing([Edge])`
- `[Node].addOutgoing([Edge])`

### Functions
- `print()`: Prints variable, string or value
- `random([from], [to])`: Generates random number within range
- List operations
	- `append([Element])`
	- `appendAll([List of elements])`
	- `remove([Element])`
	- `removeAt([Element], [Position])`
	- `insert([[Element], [Position])`
	- `copy()`

## Attributes

### Graphs
- `[Graph].nodes`
- `[Graph].edges`

### Edges
- `[Edge].from`
- `[Edge].to`
- `[Edge].weight`

### Nodes
- `[Node].id`
- `[Node].weight`
- `[Node].neighbours`
- `[Node].ingoingEdges`
- `[Node].outgoingEdges`
- `[Node].ingoingNodes`
- `[Node].outgoingNodes`

## Compiling and Running

```
In Unix based systems to compile (in root directory):
find . -name "*.java" > sources.txt                      
javac -d out -cp ".:lib/jackson/*:lib/junit/*" @sources.txt
rm sources.txt

To run (in root directory):
java -cp "out:lib/jackson/*:lib/junit/*" Tools.JSONParser
```

## Running the Script

The script takes input from a source file. It then passes this input through the parser and checks if all Java classes are compiled. If not, the script prompts the user to compile them. If they are already compiled, the script still provides an option to compile them again in case the classes have been modified. The default output of the script includes the AST generated using Python, the JSON imported by Java, the AST generated by Java, and the output of the AST Traverser.

To run the script (in the terminal, in the root directory of the project):

```bash
./run.sh [options] source
```

Options:

- -h: Show the help text explaining how ot use the script.
- -r: Recompile all Java files before running the script. 
- -d: Run the script and show debug output. 

** in case of permission errors: sudo chmod +x run.sh.
** Lark library from Python should be installed.
** JDK 21 is needed.